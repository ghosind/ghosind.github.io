---
layout: post
title: CS:APP 第一章：计算机系统漫游（3）
date: 2015-08-30
categories: csapp
tags: [csapp]
excerpt: 深入理解计算机系统学习笔记，第一章计算机系统漫游第三部分，包括第一章中的1.7 操作系统管理硬件 、1.8系统之间利用网络通信 、 1.9 重要主题 以及1.10 小结。
---

# 前言  
最近迷上了Coursera上的课程，隔了半个多月也没把这篇写完。。。然后发现在Coursera玩的有点本末倒置，变成了刷课，所以又继续滚回来写博客了。。。

---

# 1.7 操作系统管理硬件
在运行hello程序的过程中，Shell和hello程序都没有直接访问键盘、显示器、磁盘以及主存，而是依靠操作系统提供的服务。操作系统可以视为应用程序与硬件之间的一层软件，所有程序对硬件的操作都需要通过操作系统。  
![计算机系统的分层视图](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-1.png)  
操作系统的两个基本功能为：防止硬件被应用程序滥用；为应用程序提供简单一致的机制控制复杂的硬件设备。操作系统通过进程、虚拟存储器以及文件三个抽象概念来实现基本功能。  
如下图所示，文件是对I/O设备的抽象表示，虚拟存储器是对主存及I/O设备（如磁盘）的抽象表示，进程是对处理器、主存以及I/O设备的抽象表示。  
![操作系统提供的抽象表示](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-2.png)  

## 1.7.1 进程
进程是操作系统提供的如同系统上只有这个程序在运行、使用硬件设备的假象。在多数系统中，运行的进程数是多于CPU的个数的，这是通过处理器在进程之间切换实现的。操作系统实现进程间切换这种机制称之为上下文切换。  
操作系统保持跟踪进程运行需要的所有状态信息，这些状态信息就是上下文（Context），它包含了PC、寄存器文件等信息。单处理器系统只能执行一个进程，当需要把控制权转移至其它进程时，就会进行上下文切换。上下文切换即保持当前进程的上下文，恢复新进程的上下文，再将控制权交给新进程。  
![进程的上下文切换](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-3.png)  
在运行hello程序时，用到的就有两个进程——Shell进程和hello进程。Shell先开始运行，即等待命令的输入。当输入命令后，Shell会通过调用系统调用函数，此时控制权会从Shell转移至操作系统。随后，操作系统会保持Shell函数的上下文，创建hello进程及它的上下文，再将控制权交予hello进程。hello进程运行完毕后，操作系统恢复Shell的上下文，再将控制权转移给Shell，Shell将继续运行等待下一条命令。  

## 1.7.2 线程
在现代操作系统中，一个进程可以由一个或多个线程组成。每个线程都在进程的上下文中，且共享相同的代码和全局数据。在这里只是稍微提及线程的概念，在书中后续章节有深入的介绍。  

## 1.7.3 虚拟存储器
虚拟存储器是为每个进程提供独自使用主存的假象，每个进程都能看到一致的存储器，称为虚拟地址空间。下图即Linux中进程的虚拟地址空间，地址空间的底部存放程序的代码和数据，顶端是保留给系统代码和数据的空间。地址是从下往上增大的，下面将从下往上地介绍虚拟存储器的各个区域。  
![进程的虚拟地址空间](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-4.png)  
·程序代码和数据：从一个固定的地址位置开始，存放程序代码、全局变量等。  
·堆：位于程序代码和数据的上方，堆可以在运行时动态的扩展和收缩，用于为类似malloc()、free()等函数分配地址空间。  
·共享库：此部分存放类似C标准库之类的共享库的代码及数据，大约位于地址空间的中间部分。  
·栈：用户栈位于虚拟地址空间顶端（用户程序可用地址空间部分），与堆一样可以在执行期间动态扩展和收缩，用户存放局部变量等数据。  
·内核虚拟存储器：内核是作为操作系统的一部分常驻在主存中的。地址空间最顶端为内核保留且不允许应用程序读写该区域或直接调用内核中的函数。  

## 1.7.4 文件
文件就是字节序列。每一个I/O设备都可被视为文件，包括磁盘、键盘、显示器、网络等。系统的输入输出即通过Unix I/O系统调用实现读写文件。  

----------

# 1.8 系统之间利用网络通信
在单独的系统中，网络可以被视为一个I/O设备。系统可以通过网络向其他机器发送数据或从其他机器读取数据。
![网络也是I/O设备](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-5.png)  
以hello程序为例，可以在远程主机上使用telnet应用运行hello程序。下图为登录到远程主机运行Shell至运行hello程序的过程。  
![利用telnet远程运行hello程序](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-6.png)  
当在telnet客户端输入“hello”并按下回车键后，客户端会将该字符串发送至telnet服务器。telnet服务器接收到之后将其传递至Shell程序，Shell运行hello程序并将输出内容返回至telnet服务器。最后，telnet服务器通过网络将输出的内容转发给telnet客户端，然后显示在我们的终端上。  

----------

# 1.9 重要主题  
（这节开始的内容不想写了。。。偷懒了。。。扔几张图就算了。。。有空再补。。。） 
 
## 1.9.1 并发与并行  
并发是一个通过概念，指一个同时具有多个活动的系统，而并行指用并发使一个系统运行的更快。  
并行在操作系统中按系统层次结构由高到低的顺序分别强调线程级并发、指令级并行以及单指令、多数据并行。  
![多核处理器](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-7.png)  
![Intel Core i7](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-8.png)  

## 1.9.2 计算机系统中抽象的重要性
文件是对I/O的抽象，虚拟存储器是对程序存储器的抽象，进程是对正在运行的程序的抽象。而虚拟机，则是提供对整个计算机（包括操作系统、处理器和程序）的抽象。
![计算机系统提供的抽象](https://raw.githubusercontent.com/ghosind/ghosind.github.io/master/images/csapp/c1/3-9.png)  

----------

# 1.10 小结
其实第一章都是介绍的内容，不想写了。。。直接略过了。。。开始后面的主要内容。。。
